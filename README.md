## 毕业设计 
## 基于SpringBoot + Netty实现即时通讯系统
name : Im-System
* 网页端
* 移动端 todo
* 小程序 todo


## Notes
在好友关系链中toid和fromid是怎么去区分哪个是主次的
* 功能角度
* 消息流向视角
* 在 IM 通讯中，如果主要考虑消息发送的方向，通常可以将 “fromId” 视为主要的一方。例如，当用户 A（fromId）发送消息给用户 B（toId）时，“fromId” 所代表的用户 A 是消息的发起者，消息的传递路径是从 A 到 B。从这个角度看，“fromId” 在消息交互场景下更具主动性，可被看作是主方。
* 关系建立视角
* 在好友关系建立的过程中，谁先发起好友请求，谁的 ID 就可以作为 “fromId”。例如，用户 A 发送好友请求给用户 B，此时 A 的 ID 是 “fromId”，B 的 ID 是 “toId”。在这个过程中，“fromId” 所代表的用户是主动发起关系建立的一方，在关系建立的起始阶段起到主导作用。
* 数据存储和查询角度
* 索引和排序考虑
* 如果在数据库存储好友关系数据时，经常需要根据某个用户来查询其所有的好友关系（包括发送的请求和收到的请求），可以将 “fromId” 作为索引的主要依据。例如，以 “fromId” 为索引字段构建索引，可以快速查询出某个用户作为发起方的所有好友关系记录。在这种情况下，“fromId” 对于数据查询的效率优化更关键，可视为主要用于索引构建的一方，即具有一定的主次之分。
* 数据一致性维护
* 在更新或维护好友关系数据时，例如处理好友请求的接受或拒绝，通常会先根据 “fromId” 找到对应的请求记录，然后根据 “toId” 来更新关系状态。从这个操作顺序看，“fromId” 在数据更新的初始定位过程中更重要，先通过 “fromId” 定位到相关记录集，再结合 “toId” 完成具体的更新操作，“fromId” 可以被看作是在数据维护过程中有主次之分的主方。
* 业务规则和权限角度
* 权限分配规则
* 如果在 IM 系统中有基于好友关系的权限设置，例如，只有 “fromId” 所代表的用户才能设置对 “toId” 用户的某些权限（如消息免打扰、查看权限等），那么 “fromId” 在权限分配场景下是主要的一方。因为权限的授予和管理主要由 “fromId” 对应的用户操作，决定了 “toId” 用户在该好友关系中的一些访问和交互权限。
* 业务逻辑重点关注
* 在一些特殊的业务逻辑中，如统计用户主动发起的好友请求数量或者用户的 “好友请求发送成功率” 等指标时，“fromId” 是重点关注的对象。因为这些指标主要围绕用户主动发起的行为展开，所以在这种业务逻辑下，“fromId” 比 “toId” 更为主次分明，是主要用于统计和分析的一方。


IM通讯中 friendShip是什么意思
在 IM（即时通讯）中，“friendShip”（友谊关系，在代码中通常是 “friendship” 这种拼写）通常代表用户之间的好友关系相关概念。以下是详细解释：
1. 数据结构层面
   它可能是一个数据对象或者数据库表名，用于存储用户之间好友关系的详细信息。这些信息可能包括：
   好友关联的用户 ID：例如，存储两个用户的 ID 来表示他们是好友关系，通过 “from_user_id” 和 “to_user_id”（类似于前面提到的消息传递中的发送方和接收方 ID 概念）这样的字段来确定好友对。
   好友添加时间：记录两个用户成为好友的具体时间，用于展示好友关系的建立日期等功能，如 “add_time” 字段。
   好友状态：比如 “已确认好友”、“等待验证” 等状态。这可以通过一个 “status” 字段来表示，其中不同的值对应不同的好友关系状态。例如，0 表示 “等待验证”，1 表示 “已确认好友”。
2. 业务逻辑层面
   好友关系建立：
   当用户 A 发送好友请求给用户 B 时，系统会在 “friendShip” 相关的数据结构中创建一条记录，初始状态可能是 “等待验证”。一旦用户 B 接受了好友请求，这条记录的状态就会更新为 “已确认好友”，以此来表示两人之间建立了正式的好友关系。
   好友关系查询与展示：
   通过查询 “friendShip” 相关的数据，可以获取用户的好友列表。例如，对于用户 A，系统可以查询 “friendShip” 数据中所有 “from_user_id = A 的 ID 或者 to_user_id = A 的 ID 并且 status = 1（已确认好友）” 的记录，然后提取对应的好友用户 ID，进而展示用户 A 的好友列表。
   好友关系维护与管理：
   如果用户想要删除好友，系统会在 “friendShip” 数据中找到对应的好友关系记录并删除或者更新状态为 “已删除”（如果需要保留删除记录的话）。同时，还可以根据 “friendShip” 中的信息来实现好友关系的其他管理功能，如好友分组等。例如，通过在 “friendShip” 数据结构中添加 “group_id” 字段来表示好友所属的分组。

1. 数据存储基础
   数据库表结构：如前面所述，通常会有一个或多个数据库表来存储友谊关系相关的数据。这包括用户 ID 对（用于标识好友双方）、关系建立时间、关系状态（如申请中、已确认、已拉黑等），可能还会有一些扩展字段，比如好友备注、分组信息等。这些数据的存储是友谊关系管理的基础。
   数据持久化：通过数据库操作（如插入、更新、删除记录）来确保友谊关系数据在系统中的长期保存。这使得系统能够在不同的会话和设备重启后，依然能够正确获取和处理用户之间的友谊关系。
2. 业务逻辑核心
   关系建立与验证：
   请求发送：当用户发起好友请求时，系统会在数据库的友谊关系表中插入一条新记录，状态设置为 “请求发送” 或 “等待验证”。这个过程涉及到业务逻辑检查，比如是否已经是好友、是否达到好友上限等。
   请求处理：接收方处理好友请求时，系统会根据接收方的操作（接受或拒绝）更新友谊关系记录的状态。如果接受，状态变为 “已确认好友”，并且可能会触发一些其他操作，如通知双方好友关系已建立、更新双方的好友列表等。
   关系维护与更新：
   好友分组：用户可以对好友进行分组管理，这需要更新友谊关系表中的分组字段。系统会根据分组信息来展示不同分组下的好友，方便用户查找和管理。
   备注修改：当用户修改好友备注时，数据库中相应的友谊关系记录中的备注字段也会被更新。这可以帮助用户更好地识别好友。
   关系状态变更：除了正常的好友关系，还可能存在拉黑、删除等操作。这些操作会导致友谊关系表中的记录状态发生变化，并且可能会影响到消息发送、好友列表展示等其他功能。例如，拉黑好友后，双方可能无法互相发送消息，或者在好友列表中的显示方式也会有所不同。
3. 系统交互关联
   与用户界面交互：友谊关系数据会在 IM 软件的用户界面（UI）上进行展示。例如，好友列表的显示是基于友谊关系数据库中的数据进行渲染的。不同的关系状态（如在线好友、离线好友、申请中好友等）可能会以不同的图标或颜色在 UI 上展示，给用户提供直观的信息。
   与消息传递交互：友谊关系直接影响消息传递功能。只有在友谊关系为 “已确认好友”（或其他允许消息传递的关系状态）的情况下，用户之间才能正常发送和接收消息。系统在处理消息发送请求时，会先检查双方的友谊关系状态，以确保消息发送符合规则。
   与权限管理交互：友谊关系还可能与权限管理相关联。例如，某些 IM 系统允许用户设置不同好友对自己个人信息（如头像、签名、动态等）的查看权限，这些权限设置也是基于友谊关系数据进行的。